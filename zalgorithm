#pragma once
#ifndef ZALGORITHM_
#define ZALGORITHM_
#include <algorithm>
#include <numeric>
#include <type_traits>

#if defined _MSC_VER
    #pragma pack(push, _CRT_PACKING)
#endif
#define ZNODISCARD [[nodiscard]]
#if __cplusplus > 201703L
    #define ZCONSTEXPR20 constexpr
#else
    #define ZCONSTEXPR20 inline
#endif

namespace zstd {


// FUNCTION TEMPLATE for_each
template <class Cont_T, class Fn>
ZCONSTEXPR20 Fn for_each(Cont_T& Cont, Fn Func) { // perform function for each element [First, Last)
    return std::for_each(std::begin(Cont), std::end(Cont), Func);
}


// FUNCTION TEMPLATE find_if_not
template <class Cont_T, class Pr>
ZNODISCARD ZCONSTEXPR20 auto find_if_not(Cont_T& Cont, Pr Pred) {
    return std::find_if_not(std::begin(Cont), std::end(Cont), Pred);
}


// FUNCTION TEMPLATE adjacent_find
template <class Cont_T, class Pr>
ZNODISCARD ZCONSTEXPR20 auto adjacent_find(Cont_T& Cont, Pr Pred) {
    return std::adjacent_find(std::begin(Cont), std::end(Cont), Pred);
}

template <class Cont_T>
ZNODISCARD ZCONSTEXPR20 auto adjacent_find(Cont_T& Cont) { // find first matching successor
    return std::adjacent_find(std::begin(Cont), std::end(Cont));
}


// FUNCTION TEMPLATE count_if
template <class Cont_T, class Pr>
ZNODISCARD ZCONSTEXPR20 auto count_if(Cont_T& Cont, Pr Pred) {
    return std::count_if(std::begin(Cont), std::end(Cont), Pred);
}


// FUNCTION TEMPLATE mismatch
template <class Cont_T, class InIt2, class Pr>
ZNODISCARD ZCONSTEXPR20 auto mismatch(Cont_T& Cont, InIt2 First2, Pr Pred) {
    return std::mismatch(std::begin(Cont), std::end(Cont), First2, Pred);
}


// FUNCTION TEMPLATE mismatch
template <class Cont_T, class Cont_T2, class Pr>
ZNODISCARD ZCONSTEXPR20 auto mismatch(Cont_T& Cont1, Cont_T2& Cont2, Pr Pred, bool FromBeginToEnd = false) {
    return FromBeginToEnd ?
        std::mismatch(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), Pred) :
        std::mismatch(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), Pred);
}


template <class Cont_T, class InIt2>
ZNODISCARD ZCONSTEXPR20 auto mismatch(Cont_T& Cont, const InIt2 First2) {
    return std::mismatch(std::begin(Cont), std::end(Cont), First2);
}


template <class Cont_T, class Cont_T2>
ZNODISCARD ZCONSTEXPR20 auto mismatch(Cont_T& Cont1, Cont_T2& Cont2, bool FromBeginToEnd = false) {
    return FromBeginToEnd ?
        std::mismatch(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2)) :
        std::mismatch(std::begin(Cont1), std::end(Cont1), std::begin(Cont2));
}


template <class Cont_T, class InIt2, class Pr>
ZNODISCARD ZCONSTEXPR20 auto mismatch(Cont_T& Cont, InIt2 First2, InIt2 Last2, Pr Pred) {
    return std::mismatch(std::begin(Cont), std::end(Cont), First2, Last2, Pred);
}


template <class Cont_T, class InIt2>
ZNODISCARD ZCONSTEXPR20 auto mismatch(Cont_T& Cont, InIt2 First2, InIt2 Last2) {
    return std::mismatch(std::begin(Cont), std::end(Cont), First2, Last2);
}


// FUNCTION TEMPLATE is_permutation
template <class Cont_T, class FwdIt2>
ZNODISCARD ZCONSTEXPR20 bool is_permutation(Cont_T& Cont, FwdIt2 First2) {
    return std::is_permutation(std::begin(Cont), std::end(Cont), First2);
}

template <class Cont_T, class FwdIt2>
ZNODISCARD ZCONSTEXPR20 bool is_permutation(Cont_T& Cont, FwdIt2 First2, FwdIt2 Last2) {
    return std::is_permutation(std::begin(Cont), std::end(Cont), First2, Last2);
}

template <class Cont_T, class Cont_T2>
ZNODISCARD ZCONSTEXPR20 bool is_permutation(Cont_T& Cont1, Cont_T2& Cont2, bool FromBeginToEnd = false) {
    return FromBeginToEnd ?
        std::is_permutation(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2)) :
        std::is_permutation(std::begin(Cont1), std::end(Cont1), std::begin(Cont2));
}

template <class Cont_T, class FwdIt2, class Pr>
ZNODISCARD ZCONSTEXPR20 bool is_permutation(Cont_T& Cont, FwdIt2 First2, Pr Pred) {
    return std::is_permutation(std::begin(Cont), std::end(Cont), First2, Pred);
}

template <class Cont_T, class FwdIt2, class Pr>
ZNODISCARD ZCONSTEXPR20 bool is_permutation(Cont_T& Cont, FwdIt2 First2, FwdIt2 Last2, Pr Pred) {
    return std::is_permutation(std::begin(Cont), std::end(Cont), First2, Last2, Pred);
}

template <class Cont_T, class Cont_T2, class Pr>
ZNODISCARD ZCONSTEXPR20 bool is_permutation(Cont_T& Cont1, Cont_T2& Cont2, Pr Pred, bool FromBeginToEnd = false) {
    return FromBeginToEnd ?
        std::is_permutation(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), Pred) :
        std::is_permutation(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), Pred);
}


// FUNCTION TEMPLATE all_of
template <class Cont_T, class Pr>
ZNODISCARD ZCONSTEXPR20 bool all_of(Cont_T& Cont, Pr Pred) { // test if all elements satisfy Pred
    return std::all_of(std::begin(Cont), std::end(Cont), Pred);
}


// FUNCTION TEMPLATE any_of
template <class Cont_T, class Pr>
ZNODISCARD ZCONSTEXPR20 bool any_of(Cont_T& Cont, Pr Pred) {
    return std::any_of(std::begin(Cont), std::end(Cont), Pred);
}


// FUNCTION TEMPLATE none_of
template <class Cont_T, class Pr>
ZNODISCARD ZCONSTEXPR20 bool none_of(Cont_T& Cont, Pr Pred) {
    return std::none_of(std::begin(Cont), std::end(Cont), Pred);
}


// FUNCTION TEMPLATE copy_if
template <class Cont_T, class OutIt, class Pr>
ZCONSTEXPR20 auto copy_if(Cont_T& Cont, OutIt Dest, Pr Pred) { // copy each satisfying Pred
    return std::copy_if(std::begin(Cont), std::end(Cont), Dest, Pred);
}


template <class Cont_T, class Pr, class DestCont_T>
ZCONSTEXPR20 auto copy_if(Cont_T& Cont, DestCont_T& Dest, Pr Pred) { // copy each satisfying Pred
    return std::copy_if(std::begin(Cont), std::end(Cont), std::begin(Dest), Pred);
}


// FUNCTION TEMPLATE partition_copy
template <class Cont_T, class OutIt1, class OutIt2, class Pr>
ZCONSTEXPR20 auto partition_copy(Cont_T& Cont, OutIt1 Dest_true, OutIt2 Dest_false, Pr Pred) {
    return std::partition_copy(std::begin(Cont), std::end(Cont), Dest_true, Dest_false, Pred);
}

template <class Cont_T, class Dest_trueCont_T, class Dest_falseCont_T, class Pr>
ZCONSTEXPR20 auto partition_copy(Cont_T& Cont, Dest_trueCont_T& Dest_true, Dest_falseCont_T& Dest_false, Pr Pred) {
    return std::partition_copy(std::begin(Cont), std::end(Cont), std::begin(Dest_true), std::begin(Dest_false), Pred);
}


// FUNCTION TEMPLATE is_partitioned
template <class Cont_T, class Pr>
ZNODISCARD ZCONSTEXPR20 bool is_partitioned(Cont_T& Cont, Pr Pred) {
    return std::is_partitioned(std::begin(Cont), std::end(Cont), Pred);
}


// FUNCTION TEMPLATE partition_point
template <class Cont_T, class Pr>
ZNODISCARD ZCONSTEXPR20 auto partition_point(Cont_T& Cont, Pr Pred) {
    return std::partition_point(std::begin(Cont), std::end(Cont), Pred);
}

template <class Cont_T, class FwdItPat, class Pr>
ZNODISCARD ZCONSTEXPR20 auto search(Cont_T& Cont, const FwdItPat First2,
    const FwdItPat Last2, Pr Pred) { // find first [First2, Last2) satisfying Pred
    return std::search(std::begin(Cont), std::end(Cont), First2, Last2, Pred);
}

template <class Cont_T, class Cont_T2, class Pr>
ZNODISCARD ZCONSTEXPR20 auto search(Cont_T& Cont1, Cont_T2& Cont2, Pr Pred) { // find first [First2, Last2) satisfying Pred
    return std::search(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), Pred);
}


template <class Cont_T, class FwdItPat>
ZNODISCARD ZCONSTEXPR20 auto search(Cont_T& Cont, const FwdItPat First2, const FwdItPat Last2) {
    return std::search(std::begin(Cont), std::end(Cont), First2, Last2);
}


template <class Cont_T, class Cont_T2>
ZNODISCARD ZCONSTEXPR20 auto search(Cont_T& Cont1, Cont_T2& Cont2) {
    return std::search(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2));
}


template <class Cont_T, class Searcher>
ZNODISCARD ZCONSTEXPR20 auto search(Cont_T& Cont, const Searcher& Search) {
    return std::search(std::begin(Cont), std::end(Cont), Search);
}


// FUNCTION TEMPLATE search_n
template <class Cont_T, class Diff, class Ty, class Pr>
ZNODISCARD ZCONSTEXPR20 auto search_n(Cont_T& Cont, const Diff Count_raw, const Ty& Val, Pr Pred) {
    return std::search_n(std::begin(Cont), std::end(Cont), Count_raw, Val, Pred);
}


template <class Cont_T, class Diff, class Ty>
ZNODISCARD ZCONSTEXPR20 auto search_n(Cont_T& Cont, const Diff Count, const Ty& Val) {
    return std::search_n(std::begin(Cont), std::end(Cont), Count, Val);
}


// FUNCTION TEMPLATE find_end
template <class Cont_T, class FwdIt2, class Pr>
ZNODISCARD ZCONSTEXPR20 auto find_end(Cont_T& Cont, const FwdIt2 First2, const FwdIt2 Last2, Pr Pred) {
    return std::find_end(std::begin(Cont), std::end(Cont), First2, Last2, Pred);
}


// FUNCTION TEMPLATE find_end
template <class Cont_T, class Cont_T2, class Pr>
ZNODISCARD ZCONSTEXPR20 auto find_end(Cont_T& Cont1, Cont_T2& Cont2, Pr Pred) {
    return std::find_end(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), Pred);
}

template <class Cont_T, class FwdIt2>
ZNODISCARD ZCONSTEXPR20 auto find_end(Cont_T& Cont, const FwdIt2 First2, const FwdIt2 Last2) {
    return std::find_end(std::begin(Cont), std::end(Cont), First2, Last2);
}

template <class Cont_T, class Cont_T2>
ZNODISCARD ZCONSTEXPR20 auto find_end(Cont_T& Cont1, Cont_T2& Cont2) {
    return std::find_end(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2));
}


// FUNCTION TEMPLATE find_first_of
template <class Cont_T, class FwdIt2, class Pr>
ZNODISCARD ZCONSTEXPR20 auto find_first_of(Cont_T& Cont, const FwdIt2 First2, const FwdIt2 Last2, Pr Pred) {
    return std::find_first_of(std::begin(Cont), std::end(Cont), First2, Last2, Pred);
}


// FUNCTION TEMPLATE find_first_of
template <class Cont_T, class Cont_T2, class Pr>
ZNODISCARD ZCONSTEXPR20 auto find_first_of(Cont_T& Cont1, Cont_T2& Cont2, Pr Pred) {
    return std::find_first_of(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), Pred);
}

template <class Cont_T, class FwdIt2>
ZNODISCARD ZCONSTEXPR20 auto find_first_of(Cont_T& Cont, const FwdIt2 First2, const FwdIt2 Last2) { // look for one of [First2, Last2) that matches element
    return std::find_first_of(std::begin(Cont), std::end(Cont), First2, Last2);
}

template <class Cont_T, class Cont_T2>
ZNODISCARD ZCONSTEXPR20 auto find_first_of(Cont_T& Cont1, Cont_T2& Cont2) { // look for one of [First2, Last2) that matches element
    return std::find_first_of(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2));
}


// FUNCTION TEMPLATE swap_ranges
template <class Cont_T, class FwdIt2>
ZCONSTEXPR20 auto swap_ranges(Cont_T& Cont, FwdIt2 First2) {
    return std::swap_ranges(std::begin(Cont), std::end(Cont), First2);
}


// FUNCTION TEMPLATE swap_ranges
template <class Cont_T, class Cont_T2>
ZCONSTEXPR20 auto swap_ranges(Cont_T& Cont1, Cont_T2& Cont2) {
    return std::swap_ranges(std::begin(Cont1), std::end(Cont1), std::begin(Cont2));
}


// FUNCTION TEMPLATE transform
template <class Cont_T, class OutIt, class Fn>
ZCONSTEXPR20 auto transform(Cont_T& Cont, OutIt Dest, Fn Func) {
    return std::transform(std::begin(Cont), std::end(Cont), Dest, Func);
}


// FUNCTION TEMPLATE transform
template <class Cont_T, class DestCont_T, class Fn>
ZCONSTEXPR20 auto transform(Cont_T& Cont, DestCont_T& Dest, Fn Func) {
    return std::transform(std::begin(Cont), std::end(Cont), std::begin(Dest), Func);
}


template <class Cont_T, class InIt2, class OutIt, class Fn>
ZCONSTEXPR20 auto transform(Cont_T& Cont, const InIt2 First2, OutIt Dest, Fn Func) {
    return std::transform(std::begin(Cont), std::end(Cont), First2, Dest, Func);
}


template <class Cont_T, class Cont_T2, class OutIt, class Fn>
ZCONSTEXPR20 auto transform(Cont_T& Cont1, Cont_T2& Cont2, OutIt Dest, Fn Func) {
    return std::transform(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), Dest, Func);
}


template <class Cont_T, class Cont_T2, class DestCont_T, class Fn>
ZCONSTEXPR20 auto transform(Cont_T& Cont1, Cont_T2& Cont2, DestCont_T& Dest, Fn Func) {
    return std::transform(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::begin(Dest), Func);
}


// FUNCTION TEMPLATE replace
template <class Cont_T, class Ty>
ZCONSTEXPR20 void replace(Cont_T& Cont, const Ty& Oldval, const Ty& Newval) {
    return std::replace(std::begin(Cont), std::end(Cont), Oldval, Newval);
}


// FUNCTION TEMPLATE replace_if
template <class Cont_T, class Pr, class Ty>
ZCONSTEXPR20 void replace_if(Cont_T& Cont, Pr Pred, const Ty& Val) {
    return std::replace_if(std::begin(Cont), std::end(Cont), Pred, Val);
}


// FUNCTION TEMPLATE replace_copy
template <class Cont_T, class OutIt, class Ty>
ZCONSTEXPR20 auto replace_copy(Cont_T& Cont, OutIt Dest, const Ty& Oldval, const Ty& Newval) {
    return std::replace_copy(std::begin(Cont), std::end(Cont), Dest, Oldval, Newval);
}


// FUNCTION TEMPLATE replace_copy
template <class Cont_T, class DestCont_T, class Ty>
ZCONSTEXPR20 auto replace_copy(Cont_T& Cont, DestCont_T& Dest, const Ty& Oldval, const Ty& Newval) {
    return std::replace_copy(std::begin(Cont), std::end(Cont), std::begin(Dest), Oldval, Newval);
}


// FUNCTION TEMPLATE replace_copy_if
template <class Cont_T, class OutIt, class Pr, class Ty>
ZCONSTEXPR20 auto replace_copy_if(Cont_T& Cont, OutIt Dest, Pr Pred, const Ty& Val) {
    return std::replace_copy_if(std::begin(Cont), std::end(Cont), Dest, Pred, Val);
}


// FUNCTION TEMPLATE replace_copy_if
template <class Cont_T, class DestCont_T, class Pr, class Ty>
ZCONSTEXPR20 auto replace_copy_if(Cont_T& Cont, DestCont_T& Dest, Pr Pred, const Ty& Val) {
    return std::replace_copy_if(std::begin(Cont), std::end(Cont), std::begin(Dest), Pred, Val);
}


// FUNCTION TEMPLATE generate
template <class Cont_T, class Fn>
ZCONSTEXPR20 void generate(Cont_T& Cont, Fn Func) { // replace [First, Last) with Func()
    return std::generate(std::begin(Cont), std::end(Cont), Func);
}


// FUNCTION TEMPLATE remove_copy
template <class Cont_T, class OutIt, class Ty>
ZCONSTEXPR20 auto remove_copy(Cont_T& Cont, OutIt Dest, const Ty& Val) {
    return std::remove_copy(std::begin(Cont), std::end(Cont), Dest, Val);
}


// FUNCTION TEMPLATE remove_copy
template <class Cont_T, class DestCont_T, class Ty>
ZCONSTEXPR20 auto remove_copy(Cont_T& Cont, DestCont_T& Dest, const Ty& Val) {
    return std::remove_copy(std::begin(Cont), std::end(Cont), std::begin(Dest), Val);
}


// FUNCTION TEMPLATE remove_copy_if
template <class Cont_T, class OutIt, class Pr>
ZCONSTEXPR20 auto remove_copy_if(Cont_T& Cont, OutIt Dest, Pr Pred) {
    return std::remove_copy_if(std::begin(Cont), std::end(Cont), Dest, Pred);
}


// FUNCTION TEMPLATE remove_copy_if
template <class Cont_T, class DestCont_T, class Pr>
ZCONSTEXPR20 auto remove_copy_if(Cont_T& Cont, DestCont_T& Dest, Pr Pred) {
    return std::remove_copy_if(std::begin(Cont), std::end(Cont), std::begin(Dest), Pred);
}


// FUNCTION TEMPLATE unique
template <class Cont_T, class Pr>
ZNODISCARD ZCONSTEXPR20 auto unique(Cont_T& Cont, Pr Pred) {
    return std::unique(std::begin(Cont), std::end(Cont), Pred);
}

template <class Cont_T>
ZNODISCARD ZCONSTEXPR20 auto unique(Cont_T& Cont) { // remove each matching previous
    return std::unique(std::begin(Cont), std::end(Cont));
}

// clang-format on

template <class Cont_T, class OutIt, class Pr>
ZCONSTEXPR20 auto unique_copy(Cont_T& Cont, OutIt Dest, Pr Pred) {
    return std::unique_copy(std::begin(Cont), std::end(Cont), Dest, Pred);
}


template <class Cont_T, class DestCont_T, class Pr>
ZCONSTEXPR20 auto unique_copy(Cont_T& Cont, DestCont_T& Dest, Pr Pred) {
    return std::unique_copy(std::begin(Cont), std::end(Cont), std::begin(Dest), Pred);
}

template <class Cont_T, class OutIt>
ZCONSTEXPR20 auto unique_copy(Cont_T& Cont, OutIt Dest) { // copy compressing pairs that match
    return std::unique_copy(std::begin(Cont), std::end(Cont), Dest);
}

template <class Cont_T, class DestCont_T>
ZCONSTEXPR20 auto unique_copy(Cont_T& Cont, DestCont_T& Dest) { // copy compressing pairs that match
    return std::unique_copy(std::begin(Cont), std::end(Cont), std::begin(Dest));
}

// FUNCTION TEMPLATE reverse_copy
template <class Cont_T, class OutIt>
ZCONSTEXPR20 auto reverse_copy(Cont_T& Cont, OutIt Dest) {
    return std::reverse_copy(std::begin(Cont), std::end(Cont), Dest);
}

// FUNCTION TEMPLATE reverse_copy
template <class Cont_T, class DestCont_T>
ZCONSTEXPR20 auto reverse_copy(Cont_T& Cont, DestCont_T& Dest) {
    return std::reverse_copy(std::begin(Cont), std::end(Cont), std::begin(Dest));
}

// FUNCTION TEMPLATE rotate_copy
template <class Cont_T, class FwdIt, class OutIt>
ZCONSTEXPR20 auto rotate_copy(Cont_T& Cont, FwdIt Mid, OutIt Dest) {
    return std::reverse_copy(std::begin(Cont), Mid, std::end(Cont), Dest);
}

// FUNCTION TEMPLATE rotate_copy
template <class Cont_T, class OutIt>
ZCONSTEXPR20 auto rotate_copy(Cont_T& Cont, size_t Mid, OutIt Dest) {
    return std::reverse_copy(std::begin(Cont), std::advance(std::begin(Cont), Mid), std::end(Cont), Dest);
}

// FUNCTION TEMPLATE rotate_copy
template <class Cont_T, class FwdIt, class DestCont_T>
ZCONSTEXPR20 auto rotate_copy(Cont_T& Cont, FwdIt Mid, DestCont_T& Dest) {
    return std::reverse_copy(std::begin(Cont), Mid, std::end(Cont), std::begin(Dest));
}

// FUNCTION TEMPLATE rotate_copy
template <class Cont_T, class DestCont_T>
ZCONSTEXPR20 auto rotate_copy(Cont_T& Cont, size_t Mid, DestCont_T& Dest) {
    return std::reverse_copy(std::begin(Cont), std::advance(std::begin(Cont), Mid), std::end(Cont), std::begin(Dest));
}


template <class Cont_T, class Urng>
void shuffle(Cont_T& Cont, Urng&& Func) { // shuffle [First, Last) using URNG Func
    return std::shuffle(std::begin(Cont), std::end(Cont), Func);
}


// FUNCTION TEMPLATE random_shuffle WITH RANDOM FN
template <class Cont_T, class RngFn>
void random_shuffle(Cont_T& Cont, RngFn&& RngFunc) {
    return std::random_shuffle(std::begin(Cont), std::end(Cont), RngFunc);
}

template <class Cont_T>
void random_shuffle(Cont_T& Cont) { // shuffle [First, Last) using rand()
    return std::random_shuffle(std::begin(Cont), std::end(Cont));
}


// FUNCTION TEMPLATE partition
template <class Cont_T, class Pr>
ZCONSTEXPR20 auto partition(Cont_T& Cont, Pr Pred) {
    return std::partition(std::begin(Cont), std::end(Cont), Pred);
}

template <class Cont_T, class Pr>
auto stable_partition(Cont_T& Cont, Pr Pred) {
    return std::stable_partition(std::begin(Cont), std::end(Cont), Pred);
}

template <class Cont_T, class Pr>
ZCONSTEXPR20 void push_heap(Cont_T& Cont, Pr Pred) {
    return std::push_heap(std::begin(Cont), std::end(Cont), Pred);
}

template <class Cont_T>
ZCONSTEXPR20 void push_heap(Cont_T& Cont) {
    return std::push_heap(std::begin(Cont), std::end(Cont));
}

template <class Cont_T, class Pr>
ZCONSTEXPR20 void pop_heap(Cont_T& Cont, Pr Pred) {
    return std::pop_heap(std::begin(Cont), std::end(Cont), Pred);
}

template <class Cont_T>
ZCONSTEXPR20 void pop_heap(Cont_T& Cont) {
    return std::pop_heap(std::begin(Cont), std::end(Cont));
}

template <class Cont_T, class Pr>
ZCONSTEXPR20 void make_heap(Cont_T& Cont, Pr Pred) { // make [First, Last) into a heap
    return std::make_heap(std::begin(Cont), std::end(Cont), Pred);
}

template <class Cont_T>
ZCONSTEXPR20 void make_heap(Cont_T& Cont) { // make [First, Last) into a heap
    return std::make_heap(std::begin(Cont), std::end(Cont));
}


template <class Cont_T, class Pr>
ZNODISCARD ZCONSTEXPR20 auto is_heap_until(Cont_T& Cont, Pr Pred) {
    return std::is_heap_until(std::begin(Cont), std::end(Cont), Pred);
}

template <class Cont_T, class Pr>
ZNODISCARD ZCONSTEXPR20 bool is_heap(Cont_T& Cont, Pr Pred) {
    return std::is_heap(std::begin(Cont), std::end(Cont), Pred);
}

template <class Cont_T>
ZNODISCARD ZCONSTEXPR20 auto is_heap_until(Cont_T& Cont) {
    return std::is_heap_until(std::begin(Cont), std::end(Cont));
}

template <class Cont_T>
ZNODISCARD ZCONSTEXPR20 bool is_heap(Cont_T& Cont) { // test if range is a heap ordered by operator<
    return std::is_heap(std::begin(Cont), std::end(Cont));
}

template <class Cont_T, class Pr>
ZCONSTEXPR20 void sort_heap(Cont_T& Cont, Pr Pred) { // order heap by repeatedly popping
    return std::sort_heap(std::begin(Cont), std::end(Cont), Pred);
}

template <class Cont_T>
ZCONSTEXPR20 void sort_heap(Cont_T& Cont) { // order heap by repeatedly popping
    return std::sort_heap(std::begin(Cont), std::end(Cont));
}


// FUNCTION TEMPLATE upper_bound
template <class Ty, class Pr, class Cont_T>
ZNODISCARD ZCONSTEXPR20 auto upper_bound(Cont_T& Cont, const Ty& Val, Pr Pred) {
    return std::upper_bound(std::begin(Cont), std::end(Cont), Val, Pred);
}

template <class Cont_T, class Ty>
ZNODISCARD ZCONSTEXPR20 auto upper_bound(Cont_T& Cont, const Ty& Val) {
    return std::upper_bound(std::begin(Cont), std::end(Cont), Val);
}


// FUNCTION TEMPLATE equal_range
template <class Cont_T, class Ty, class Pr>
ZNODISCARD ZCONSTEXPR20 auto equal_range(Cont_T& Cont, const Ty& Val, Pr Pred) {
    return std::equal_range(std::begin(Cont), std::end(Cont), Val, Pred);
}

template <class Cont_T, class Ty>
ZNODISCARD ZCONSTEXPR20 auto equal_range(Cont_T& Cont, const Ty& Val) {
    return std::equal_range(std::begin(Cont), std::end(Cont), Val);
}


// FUNCTION TEMPLATE binary_search
template <class Cont_T, class Ty, class Pr>
ZNODISCARD ZCONSTEXPR20 bool binary_search(Cont_T& Cont, const Ty& Val, Pr Pred) {
    return std::binary_search(std::begin(Cont), std::end(Cont), Val, Pred);
}

template <class Cont_T, class Ty>
ZNODISCARD ZCONSTEXPR20 bool binary_search(Cont_T& Cont, const Ty& Val) {
    return std::binary_search(std::begin(Cont), std::end(Cont), Val);
}

template <class Cont_T, class InIt2, class OutIt, class Pr>
ZCONSTEXPR20 auto merge(Cont_T& Cont, InIt2 First2, InIt2 Last2, OutIt Dest, Pr Pred) {
    return std::merge(std::begin(Cont), std::end(Cont), First2, Last2, Dest, Pred);
}

template <class Cont_T, class Cont_T2, class OutIt, class Pr>
ZCONSTEXPR20 auto merge(Cont_T& Cont1, Cont_T2& Cont2, OutIt Dest, Pr Pred) {
    return std::merge(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), Dest, Pred);
}

template <class Cont_T, class Cont_T2, class DestCont_T, class Pr>
ZCONSTEXPR20 auto merge(Cont_T& Cont1, Cont_T2& Cont2, DestCont_T& Dest, Pr Pred) {
    return std::merge(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), std::begin(Dest), Pred);
}

template <class Cont_T, class InIt2, class OutIt>
ZCONSTEXPR20 auto merge(Cont_T& Cont, InIt2 First2, InIt2 Last2, OutIt Dest) {
    return std::merge(std::begin(Cont), std::end(Cont), First2, Last2, Dest);
}

template <class Cont_T, class Cont_T2, class OutIt>
ZCONSTEXPR20 auto merge(Cont_T& Cont1, Cont_T2& Cont2, OutIt Dest) {
    return std::merge(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), Dest);
}

template <class Cont_T, class Cont_T2, class DestCont_T>
ZCONSTEXPR20 auto merge(Cont_T& Cont1, Cont_T2& Cont2, DestCont_T& Dest) {
    return std::merge(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), std::begin(Dest));
}

template <class Cont_T, class BidIt, class Pr>
void inplace_merge(Cont_T& Cont, BidIt Mid, Pr Pred) {
    return std::inplace_merge(std::begin(Cont), Mid, std::end(Cont), Pred);
}

template <class Cont_T, class Pr>
void inplace_merge(Cont_T& Cont, size_t Mid, Pr Pred) {
    return std::inplace_merge(std::begin(Cont), std::advance(std::begin(Cont), Mid), std::end(Cont), Pred);
}

template <class Cont_T, class BidIt>
void inplace_merge(Cont_T& Cont, BidIt Mid) {
    return std::inplace_merge(std::begin(Cont), Mid, std::end(Cont));
}

template <class Cont_T>
void inplace_merge(Cont_T& Cont, size_t Mid) {
    return std::inplace_merge(std::begin(Cont), std::advance(std::begin(Cont), Mid), std::end(Cont));
}


template <class Cont_T, class Pr>
ZCONSTEXPR20 void sort(Cont_T& Cont, Pr Pred) { // order [First, Last)
    return std::sort(std::begin(Cont), std::end(Cont), Pred);
}

template <class Cont_T>
ZCONSTEXPR20 void sort(Cont_T& Cont) { // order [First, Last)
    return std::sort(std::begin(Cont), std::end(Cont));
}

template <class Cont_T, class Pr>
void stable_sort(Cont_T& Cont, Pr Pred) {
    return std::stable_sort(std::begin(Cont), std::end(Cont), Pred);
}


template <class Cont_T>
void stable_sort(Cont_T& Cont) { // sort preserving order of equivalents
    return std::stable_sort(std::begin(Cont), std::end(Cont));
}


// FUNCTION TEMPLATE partial_sort_copy
template <class Cont_T, class RanIt, class Pr>
ZCONSTEXPR20 auto partial_sort_copy(Cont_T& Cont, RanIt First2, RanIt Last2, Pr Pred) {
    return std::partial_sort_copy(std::begin(Cont), std::end(Cont), First2, Last2, Pred);
}


// FUNCTION TEMPLATE partial_sort_copy
template <class Cont_T, class Cont_T2, class Pr>
ZCONSTEXPR20 auto partial_sort_copy(Cont_T& Cont1, Cont_T2& Cont2, Pr Pred) {
    return std::partial_sort_copy(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), Pred);
}

template <class Cont_T, class RanIt>
ZCONSTEXPR20 auto partial_sort_copy(Cont_T& Cont, RanIt First2, RanIt Last2) {
    return std::partial_sort_copy(std::begin(Cont), std::end(Cont), First2, Last2);
}

template <class Cont_T, class Cont_T2>
ZCONSTEXPR20 auto partial_sort_copy(Cont_T& Cont1, Cont_T2& Cont2) {
    return std::partial_sort_copy(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2));
}


// FUNCTION TEMPLATE includes
template <class Cont_T, class InIt2, class Pr>
ZNODISCARD ZCONSTEXPR20 bool includes(Cont_T& Cont, InIt2 First2, InIt2 Last2, Pr Pred) {
    return std::includes(std::begin(Cont), std::end(Cont), First2, Last2, Pred);
}


// FUNCTION TEMPLATE includes
template <class Cont_T, class Cont_T2, class Pr>
ZNODISCARD ZCONSTEXPR20 bool includes(Cont_T& Cont1, Cont_T2& Cont2, Pr Pred) {
    return std::includes(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), Pred);
}

template <class Cont_T, class InIt2>
ZNODISCARD ZCONSTEXPR20 bool includes(Cont_T& Cont, InIt2 First2, InIt2 Last2) {
    return std::includes(std::begin(Cont), std::end(Cont), First2, Last2);
}

template <class Cont_T, class Cont_T2>
ZNODISCARD ZCONSTEXPR20 bool includes(Cont_T& Cont1, Cont_T2& Cont2) {
    return std::includes(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2));
}


// FUNCTION TEMPLATE set_union
template <class Cont_T, class InIt2, class OutIt, class Pr>
ZCONSTEXPR20 auto set_union(Cont_T& Cont, InIt2 First2, InIt2 Last2, OutIt Dest, Pr Pred) {
    return std::set_union(std::begin(Cont), std::end(Cont), First2, Last2, Dest, Pred);
}


// FUNCTION TEMPLATE set_union
template <class Cont_T, class Cont_T2, class OutIt, class Pr>
ZCONSTEXPR20 auto set_union(Cont_T& Cont1, Cont_T2& Cont2, OutIt Dest, Pr Pred) {
    return std::set_union(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), Dest, Pred);
}


// FUNCTION TEMPLATE set_union
template <class Cont_T, class Cont_T2, class DestCont_T, class Pr>
ZCONSTEXPR20 auto set_union(Cont_T& Cont1, Cont_T2& Cont2, DestCont_T& Dest, Pr Pred) {
    return std::set_union(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), std::begin(Dest), Pred);
}

template <class Cont_T, class InIt2, class OutIt>
ZCONSTEXPR20 auto set_union(Cont_T& Cont, InIt2 First2, InIt2 Last2, OutIt Dest) {
    return std::set_union(std::begin(Cont), std::end(Cont), First2, Last2, Dest);
}

template <class Cont_T, class Cont_T2, class OutIt>
ZCONSTEXPR20 auto set_union(Cont_T& Cont1, Cont_T2& Cont2, OutIt Dest) {
    return std::set_union(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), Dest);
}

template <class Cont_T, class Cont_T2, class DestCont_T>
ZCONSTEXPR20 auto set_union(Cont_T& Cont1, Cont_T2& Cont2, DestCont_T& Dest) {
    return std::set_union(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), std::begin(Dest));
}


// FUNCTION TEMPLATE set_intersection
template <class Cont_T, class InIt2, class OutIt, class Pr>
ZCONSTEXPR20 auto set_intersection(Cont_T& Cont, InIt2 First2, InIt2 Last2, OutIt Dest, Pr Pred) {
    return std::set_intersection(std::begin(Cont), std::end(Cont), First2, Last2, Dest, Pred);
}


// FUNCTION TEMPLATE set_intersection
template <class Cont_T, class Cont_T2, class OutIt, class Pr>
ZCONSTEXPR20 auto set_intersection(Cont_T& Cont1, Cont_T2& Cont2, OutIt Dest, Pr Pred) {
    return std::set_intersection(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), Dest, Pred);
}


// FUNCTION TEMPLATE set_intersection
template <class Cont_T, class Cont_T2, class DestCont_T, class Pr>
ZCONSTEXPR20 auto set_intersection(Cont_T& Cont1, Cont_T2& Cont2, DestCont_T& Dest, Pr Pred) {
    return std::set_intersection(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), std::begin(Dest), Pred);
}

template <class Cont_T, class InIt2, class OutIt>
ZCONSTEXPR20 auto set_intersection(Cont_T& Cont, InIt2 First2, InIt2 Last2, OutIt Dest) {
    return std::set_intersection(std::begin(Cont), std::end(Cont), First2, Last2, Dest);
}

template <class Cont_T, class Cont_T2, class OutIt>
ZCONSTEXPR20 auto set_intersection(Cont_T& Cont1, Cont_T2& Cont2, OutIt Dest) {
    return std::set_intersection(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), Dest);
}

template <class Cont_T, class Cont_T2, class DestCont_T>
ZCONSTEXPR20 auto set_intersection(Cont_T& Cont1, Cont_T2& Cont2, DestCont_T& Dest) {
    return std::set_intersection(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), std::begin(Dest));
}


// FUNCTION TEMPLATE set_difference
template <class Cont_T, class InIt2, class OutIt, class Pr>
ZCONSTEXPR20 auto set_difference(Cont_T& Cont, InIt2 First2, InIt2 Last2, OutIt Dest, Pr Pred) {
    return std::set_difference(std::begin(Cont), std::end(Cont), First2, Last2, Dest, Pred);
}


// FUNCTION TEMPLATE set_difference
template <class Cont_T, class Cont_T2, class OutIt, class Pr>
ZCONSTEXPR20 auto set_difference(Cont_T& Cont1, Cont_T2& Cont2, OutIt Dest, Pr Pred) {
    return std::set_difference(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), Dest, Pred);
}


// FUNCTION TEMPLATE set_difference
template <class Cont_T, class Cont_T2, class DestCont_T, class Pr>
ZCONSTEXPR20 auto set_difference(Cont_T& Cont1, Cont_T2& Cont2, DestCont_T& Dest, Pr Pred) {
    return std::set_difference(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), std::begin(Dest), Pred);
}

template <class Cont_T, class InIt2, class OutIt>
ZCONSTEXPR20 auto set_difference(Cont_T& Cont, InIt2 First2, InIt2 Last2, OutIt Dest) {
    return std::set_difference(std::begin(Cont), std::end(Cont), First2, Last2, Dest);
}

template <class Cont_T, class Cont_T2, class OutIt>
ZCONSTEXPR20 auto set_difference(Cont_T& Cont1, Cont_T2& Cont2, OutIt Dest) {
    return std::set_difference(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), Dest);
}

template <class Cont_T, class Cont_T2, class DestCont_T>
ZCONSTEXPR20 auto set_difference(Cont_T& Cont1, Cont_T2& Cont2, DestCont_T& Dest) {
    return std::set_difference(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), std::begin(Dest));
}


// FUNCTION TEMPLATE set_symmetric_difference
template <class Cont_T, class InIt2, class OutIt, class Pr>
ZCONSTEXPR20 auto set_symmetric_difference(Cont_T& Cont, InIt2 First2, InIt2 Last2, OutIt Dest, Pr Pred) {
    return std::set_symmetric_difference(std::begin(Cont), std::end(Cont), First2, Last2, Dest, Pred);
}


// FUNCTION TEMPLATE set_symmetric_difference
template <class Cont_T, class Cont_T2, class OutIt, class Pr>
ZCONSTEXPR20 auto set_symmetric_difference(Cont_T& Cont1, Cont_T2& Cont2, OutIt Dest, Pr Pred) {
    return std::set_symmetric_difference(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), Dest, Pred);
}


// FUNCTION TEMPLATE set_symmetric_difference
template <class Cont_T, class Cont_T2, class DestCont_T, class Pr>
ZCONSTEXPR20 auto set_symmetric_difference(Cont_T& Cont1, Cont_T2& Cont2, DestCont_T& Dest, Pr Pred) {
    return std::set_symmetric_difference(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), std::begin(Dest), Pred);
}

template <class Cont_T, class InIt2, class OutIt>
ZCONSTEXPR20 auto set_symmetric_difference(Cont_T& Cont, InIt2 First2, InIt2 Last2, OutIt Dest) {
    return std::set_symmetric_difference(std::begin(Cont), std::end(Cont), First2, Last2, Dest);
}

template <class Cont_T, class Cont_T2, class OutIt>
ZCONSTEXPR20 auto set_symmetric_difference(Cont_T& Cont1, Cont_T2& Cont2, OutIt Dest) {
    return std::set_symmetric_difference(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), Dest);
}

template <class Cont_T, class Cont_T2, class DestCont_T>
ZCONSTEXPR20 auto set_symmetric_difference(Cont_T& Cont1, Cont_T2& Cont2, DestCont_T& Dest) {
    return std::set_symmetric_difference(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), std::end(Cont2), std::begin(Dest));
}


template <class Cont_T, class Pr>
ZNODISCARD ZCONSTEXPR20 auto max_element(Cont_T& Cont, Pr Pred) { // find largest element
    return std::max_element(std::begin(Cont), std::end(Cont), Pred);
}

template <class Cont_T>
ZNODISCARD ZCONSTEXPR20 auto max_element(Cont_T& Cont) { // find largest element
    return std::max_element(std::begin(Cont), std::end(Cont));
}


// FUNCTION TEMPLATE min_element
template <class Cont_T, class Pr>
ZNODISCARD ZCONSTEXPR20 auto min_element(Cont_T& Cont, Pr Pred) { // find smallest element
    return std::min_element(std::begin(Cont), std::end(Cont), Pred);
}

template <class Cont_T>
ZNODISCARD ZCONSTEXPR20 auto min_element(Cont_T& Cont) { // find smallest element
    return std::min_element(std::begin(Cont), std::end(Cont));
}


// FUNCTION TEMPLATE minmax_element
template <class Cont_T, class Pr>
ZNODISCARD ZCONSTEXPR20 auto minmax_element(Cont_T& Cont, Pr Pred) {
    return std::minmax_element(std::begin(Cont), std::end(Cont), Pred);
}

template <class Cont_T>
ZNODISCARD ZCONSTEXPR20 auto minmax_element(Cont_T& Cont) {
    return std::minmax_element(std::begin(Cont), std::end(Cont));
}


// FUNCTION TEMPLATE next_permutation
template <class Cont_T, class Pr>
ZCONSTEXPR20 bool next_permutation(Cont_T& Cont, Pr Pred) {
    return std::next_permutation(std::begin(Cont), std::end(Cont), Pred);
}

template <class Cont_T>
ZCONSTEXPR20 bool next_permutation(Cont_T& Cont) {
    return std::next_permutation(std::begin(Cont), std::end(Cont));
}


// FUNCTION TEMPLATE prev_permutation
template <class Cont_T, class Pr>
ZCONSTEXPR20 bool prev_permutation(Cont_T& Cont, Pr Pred) {
    return std::prev_permutation(std::begin(Cont), std::end(Cont), Pred);
}

template <class Cont_T>
ZCONSTEXPR20 bool prev_permutation(Cont_T& Cont) {
    return std::prev_permutation(std::begin(Cont), std::end(Cont));
}


// FUNCTION TEMPLATES is_sorted AND is_sorted_until
template <class Cont_T, class Pr>
ZNODISCARD ZCONSTEXPR20 auto is_sorted_until(Cont_T& Cont, Pr Pred) {
    return std::is_sorted_until(std::begin(Cont), std::end(Cont), Pred);
}

template <class Cont_T, class Pr>
ZNODISCARD ZCONSTEXPR20 bool is_sorted(Cont_T& Cont, Pr Pred) {
    return std::is_sorted(std::begin(Cont), std::end(Cont), Pred);
}

template <class Cont_T>
ZNODISCARD ZCONSTEXPR20 auto is_sorted_until(Cont_T& Cont) {
    return std::is_sorted_until(std::begin(Cont), std::end(Cont));
}

template <class Cont_T>
ZNODISCARD ZCONSTEXPR20 bool is_sorted(Cont_T& Cont) { // test if range is ordered by operator<
    return std::is_sorted(std::begin(Cont), std::end(Cont));
}

//numeric

template <class Cont_T, class Ty, class Fn>
ZNODISCARD ZCONSTEXPR20 Ty accumulate(Cont_T& Cont, Ty Val, Fn Reduce_op) {
    return std::accumulate(std::begin(Cont), std::end(Cont), Val, Reduce_op);
}

template <class Cont_T, class Ty>
ZNODISCARD ZCONSTEXPR20 Ty accumulate(Cont_T& Cont, Ty Val) {
    return std::accumulate(std::begin(Cont), std::end(Cont), Val);
}

template <class Cont_T>
ZNODISCARD ZCONSTEXPR20 auto acc(Cont_T& Cont) {
    return std::accumulate(std::begin(Cont), std::end(Cont), typename std::remove_reference<decltype(*(std::begin(Cont)))>::type());
}

template<typename T>
struct zbfunction_traits;

template<typename T>
struct zbfunction_traits : zbfunction_traits<decltype( &T::operator() )>
{
};

template<typename R, typename Arg1, typename Arg2>
struct zbfunction_traits<R(*)(Arg1, Arg2)>
{
    using result_type = R;
    using param1 = Arg1;
    using param2 = Arg2;
};

template<typename C, typename R, typename Arg1, typename Arg2>
struct zbfunction_traits<R( C::* )( Arg1, Arg2 )>
{
    using result_type = R;
    using param1 = Arg1;
    using param2 = Arg2;
};

template<typename C, typename R, typename Arg1, typename Arg2>
struct zbfunction_traits<R( C::* )( Arg1, Arg2 ) const>
{
    using result_type = R;
    using param1 = Arg1;
    using param2 = Arg2;
};

template <class Cont_T, class Fn>
ZNODISCARD ZCONSTEXPR20 auto acc(Cont_T& Cont, Fn Reduce_op) {
    return std::accumulate(std::begin(Cont), std::end(Cont),
            typename zbfunction_traits<Fn>::result_type(), Reduce_op);
}

template <class Cont_T, class Ty, template<class...> typename Fn>
ZNODISCARD ZCONSTEXPR20 auto acc(Cont_T& Cont, Fn<Ty> Reduce_op) {
    return std::accumulate(std::begin(Cont), std::end(Cont),
            typename zbfunction_traits<decltype(Fn<typename std::remove_reference<decltype(*std::begin(Cont))>::type>())>::result_type(), Reduce_op);
}

// FUNCTION TEMPLATE inner_product
template <class Cont_T, class InIt2, class Ty, class BinOp1, class BinOp2>
ZNODISCARD ZCONSTEXPR20 Ty inner_product(
    Cont_T& Cont, InIt2 First2, Ty Val, BinOp1 Reduce_op, BinOp2 Transform_op) {
    return std::inner_product(std::begin(Cont), std::end(Cont), First2, Val, Reduce_op, Transform_op);
}

// FUNCTION TEMPLATE inner_product
template <class Cont_T1, class Cont_T2, class Ty, class BinOp1, class BinOp2>
ZNODISCARD ZCONSTEXPR20 Ty inner_product(
    Cont_T1& Cont1, Cont_T2& Cont2, Ty Val, BinOp1 Reduce_op, BinOp2 Transform_op) {
    return std::inner_product(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), Val, Reduce_op, Transform_op);
}

template <class Cont_T, class InIt2, class Ty>
ZNODISCARD ZCONSTEXPR20 Ty inner_product(Cont_T& Cont, const InIt2 First2, Ty Val) {
    return std::inner_product(std::begin(Cont), std::end(Cont), First2, move(Val));
}

template <class Cont_T1, class Cont_T2, class Ty>
ZNODISCARD ZCONSTEXPR20 Ty inner_product(Cont_T1& Cont1, Cont_T2& Cont2, Ty Val) {
    return std::inner_product(std::begin(Cont1), std::end(Cont1), std::begin(Cont2), move(Val));
}

// FUNCTION TEMPLATE partial_sum
template <class Cont_T, class OutIt, class BinOp>
ZCONSTEXPR20 auto partial_sum(Cont_T& Cont, OutIt Dest, BinOp Reduce_op) {
    return std::partial_sum(std::begin(Cont), std::end(Cont), Dest, Reduce_op);
}

template <class Cont_T1, class Cont_T2, class BinOp>
ZCONSTEXPR20 auto partial_sum(Cont_T1& Cont, Cont_T2& Dest, BinOp Reduce_op) {
    return std::partial_sum(std::begin(Cont), std::end(Cont), std::begin(Dest), Reduce_op);
}

template <class Cont_T, class OutIt>
ZCONSTEXPR20 auto partial_sum(Cont_T& Cont, OutIt Dest) {
    return std::partial_sum(std::begin(Cont), std::end(Cont), Dest);
}

template <class Cont_T1, class Cont_T2>
ZCONSTEXPR20 auto partial_sum(Cont_T1& Cont, Cont_T2& Dest) {
    return std::partial_sum(std::begin(Cont), std::end(Cont), std::begin(Dest));
}

// FUNCTION TEMPLATE adjacent_difference
template <class Cont_T, class OutIt, class BinOp>
ZCONSTEXPR20 auto adjacent_difference(Cont_T& Cont, OutIt Dest, BinOp Func) {
    return std::adjacent_difference(std::begin(Cont), std::end(Cont), Dest, Func);
}

template <class Cont_T1, class Cont_T2, class BinOp>
ZCONSTEXPR20 auto adjacent_difference(Cont_T1& Cont, Cont_T2& Dest, BinOp Func) {
    return std::adjacent_difference(std::begin(Cont), std::end(Cont), std::begin(Dest), Func);
}

template <class Cont_T, class OutIt>
ZCONSTEXPR20 auto adjacent_difference(Cont_T& Cont, OutIt Dest) {
    return std::adjacent_difference(std::begin(Cont), std::end(Cont), Dest);
}

template <class Cont_T1, class Cont_T2>
ZCONSTEXPR20 auto adjacent_difference(Cont_T1& Cont, Cont_T2& Dest) {
    return std::adjacent_difference(std::begin(Cont), std::end(Cont), std::begin(Dest));
}

// FUNCTION TEMPLATE iota
template <class Cont_T, class Ty>
ZCONSTEXPR20 void iota(Cont_T& Cont, Ty Val) {
    return std::iota(std::begin(Cont), std::end(Cont), Val);
}


// FUNCTION TEMPLATE distance
template <class Cont_T>
ZNODISCARD ZCONSTEXPR20 auto distance(Cont_T& Cont) {
    return std::distance(std::begin(Cont), std::end(Cont));
}

// FUNCTION TEMPLATE copy
template <class Cont_T, class OutIt>
ZCONSTEXPR20 auto copy(Cont_T& Cont, OutIt Dest) {
    return std::copy(std::begin(Cont), std::end(Cont), Dest);
}

template <class Cont_T1, class Cont_T2>
ZCONSTEXPR20 auto copy(Cont_T1& Cont, Cont_T2& Dest) {
    return std::copy(std::begin(Cont), std::end(Cont), std::begin(Dest));
}

// FUNCTION TEMPLATE copy_n
template <class Cont_T, class Diff, class OutIt>
ZCONSTEXPR20 auto copy_n(Cont_T& Cont, Diff Count_raw, OutIt Dest) {
    return std::copy_n(std::begin(Cont), Count_raw, Dest);
}

template <class Cont_T1, class Diff, class Cont_T2>
ZCONSTEXPR20 auto copy_n(Cont_T1& Cont, Diff Count_raw, Cont_T2& Dest) {
    return std::copy_n(std::begin(Cont), Count_raw, std::begin(Dest));
}

template <class Cont_T, class BidIt2>
ZCONSTEXPR20 auto copy_backward(Cont_T& Cont, BidIt2 Dest) {
    return std::copy_backward(std::begin(Cont), std::end(Cont), Dest);
}

template <class Cont_T1, class Cont_T2>
ZCONSTEXPR20 auto copy_backward(Cont_T1& Cont, Cont_T2& Dest) {
    return std::copy_backward(std::begin(Cont), std::end(Cont), std::begin(Dest));
}

template <class Cont_T, class OutIt>
ZCONSTEXPR20 auto move(Cont_T& Cont, OutIt Dest) {
    return std::move(std::begin(Cont), std::end(Cont), Dest);
}

template <class Cont_T1, class Cont_T2>
ZCONSTEXPR20 auto move(Cont_T1& Cont, Cont_T2& Dest) {
    return std::move(std::begin(Cont), std::end(Cont), std::begin(Dest));
}

template <class Cont_T, class BidIt2>
ZCONSTEXPR20 auto move_backward(Cont_T& Cont, BidIt2 Dest) {
    return std::move_backward(std::begin(Cont), std::end(Cont), Dest);
}

template <class Cont_T1, class Cont_T2>
ZCONSTEXPR20 auto move_backward(Cont_T1& Cont, Cont_T2& Dest) {
    return std::move_backward(std::begin(Cont), std::end(Cont), std::begin(Dest));
}

// FUNCTION TEMPLATE fill
template <class Cont_T, class Ty>
ZCONSTEXPR20 void fill(Cont_T& Cont, const Ty& Val) {
    return std::fill(std::begin(Cont), std::end(Cont), Val);
}

// FUNCTION TEMPLATE fill_n
template <class Cont_T, class Diff, class Ty>
ZCONSTEXPR20 auto fill_n(Cont_T& Dest, const Diff Count_raw, const Ty& Val) {
    return std::fill(std::begin(Dest), Count_raw, Val);
}

template <class Cont_T, class InIt2, class Pr>
ZNODISCARD ZCONSTEXPR20 bool equal(Cont_T& Cont, const InIt2 First2, Pr Pred) {
    return std::equal(std::begin(Cont), std::end(Cont), First2, Pred);
}

template <class Cont_T, class InIt2, class Pr>
ZNODISCARD ZCONSTEXPR20 bool equal(Cont_T& Cont, const InIt2 First2, const InIt2 Last2, Pr Pred) {
    return std::equal(std::begin(Cont), std::end(Cont), First2, Last2, Pred);
}

template <class Cont_T1, class Cont_T2, class Pr>
ZNODISCARD ZCONSTEXPR20 bool equal(Cont_T1& Cont, Cont_T2& Cont2, Pr Pred, bool FromBeginToEnd = false) {
    return FromBeginToEnd ?
        std::equal(std::begin(Cont), std::end(Cont), std::begin(Cont2), std::end(Cont2), Pred) :
        std::equal(std::begin(Cont), std::end(Cont), std::begin(Cont2), Pred);
}

template <class Cont_T, class InIt2>
ZNODISCARD ZCONSTEXPR20 bool equal(Cont_T& Cont, const InIt2 First2) {
    return std::equal(std::begin(Cont), std::end(Cont), First2);
}


template <class Cont_T, class InIt2>
ZNODISCARD ZCONSTEXPR20 bool equal(Cont_T& Cont, const InIt2 First2, const InIt2 Last2) {
    return std::equal(std::begin(Cont), std::end(Cont), First2, Last2);
}

template <class Cont_T1, class Cont_T2>
ZNODISCARD ZCONSTEXPR20 bool equal(Cont_T1& Cont, Cont_T2& Cont2, bool FromBeginToEnd = false) {
    return FromBeginToEnd ?
        std::equal(std::begin(Cont), std::end(Cont), std::begin(Cont2), std::end(Cont2)) :
        std::equal(std::begin(Cont), std::end(Cont), std::begin(Cont2));
}

template <class Cont_T, class InIt2, class Pr>
ZNODISCARD ZCONSTEXPR20 bool lexicographical_compare(Cont_T& Cont, InIt2 First2, InIt2 Last2, Pr Pred) {
    return std::lexicographical_compare(std::begin(Cont), std::end(Cont), First2, Last2, Pred);
}

template <class Cont_T1, class Cont_T2, class Pr>
ZNODISCARD ZCONSTEXPR20 bool lexicographical_compare(Cont_T1& Cont, Cont_T2& Cont2, Pr Pred) {
    return std::lexicographical_compare(std::begin(Cont), std::end(Cont), std::begin(Cont2), std::end(Cont2), Pred);
}

template <class Cont_T, class InIt2>
ZNODISCARD ZCONSTEXPR20 bool lexicographical_compare(Cont_T& Cont, InIt2 First2, InIt2 Last2) {
    return std::lexicographical_compare(std::begin(Cont), std::end(Cont), First2, Last2);
}

template <class Cont_T1, class Cont_T2>
ZNODISCARD ZCONSTEXPR20 bool lexicographical_compare(Cont_T1& Cont, Cont_T2& Cont2) {
    return std::lexicographical_compare(std::begin(Cont), std::end(Cont), std::begin(Cont2), std::end(Cont2));
}

template <class Cont_T, class Ty>
ZNODISCARD ZCONSTEXPR20 auto find(Cont_T& Cont, const Ty& Val) {
    return std::find(std::begin(Cont), std::end(Cont), Val);
}

// FUNCTION TEMPLATE count
template <class Cont_T, class Ty>
ZNODISCARD ZCONSTEXPR20 auto count(Cont_T& Cont, const Ty& Val) {
    return std::equal(std::begin(Cont), std::end(Cont), Val);
}

// FUNCTION TEMPLATE reverse
template <class Cont_T>
ZCONSTEXPR20 void reverse(Cont_T& Cont) {
    return std::reverse(std::begin(Cont), std::end(Cont));
}

template <class Cont_T, class FwdIt>
ZCONSTEXPR20 auto rotate(Cont_T& Cont, FwdIt Mid) {
    return std::rotate(std::begin(Cont), Mid, std::end(Cont));
}

template <class Cont_T>
ZCONSTEXPR20 auto rotate(Cont_T& Cont, size_t Mid) {
    return std::rotate(std::begin(Cont), std::advance(std::begin(Cont), Mid), std::end(Cont));
}

// FUNCTION TEMPLATE find_if
template <class Cont_T, class Pr>
ZNODISCARD ZCONSTEXPR20 auto find_if(Cont_T& Cont, Pr Pred) { // find first satisfying Pred
    return std::find_if(std::begin(Cont), std::end(Cont), Pred);
}

// FUNCTION TEMPLATE lower_bound
template <class Cont_T, class Ty, class Pr>
ZNODISCARD ZCONSTEXPR20 auto lower_bound(Cont_T& Cont, const Ty& Val, Pr Pred) {
    return std::lower_bound(std::begin(Cont), std::end(Cont), Val, Pred);
}

template <class Cont_T, class Ty>
ZNODISCARD ZCONSTEXPR20 auto lower_bound(Cont_T& Cont, const Ty& Val) {
    return std::lower_bound(std::begin(Cont), std::end(Cont), Val);
}

} // namespace std

#if defined _MSC_VER
    #pragma pack(pop)
#endif
#undef ZNODISCARD
#undef ZCONSTEXPR20

#endif // ZALGORITHM_
